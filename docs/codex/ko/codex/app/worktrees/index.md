# 워크트리

원본 URL: https://developers.openai.com/codex/app/worktrees

Codex 앱에서 워크트리를 사용하면 같은 프로젝트 안에서 서로 간섭 없이 여러 독립 작업을 Codex가 실행할 수 있습니다. Git 저장소의 경우 [automations](https://developers.openai.com/codex/app/automations)는 전용 백그라운드 워크트리에서 실행되므로 진행 중인 작업과 충돌하지 않습니다. 버전 관리가 없는 프로젝트에서는 automations가 프로젝트 디렉터리에서 직접 실행됩니다. 워크트리에서 스레드를 수동으로 시작할 수도 있습니다.

## 워크트리란 무엇인가

워크트리는 내부적으로 [Git worktrees](https://git-scm.com/docs/git-worktree)를 사용하므로 Git 저장소에 포함된 프로젝트에서만 동작합니다. 워크트리를 사용하면 저장소의 두 번째 복사본(“checkout”)을 만들 수 있습니다. 각 워크트리는 저장소의 모든 파일 사본을 자체적으로 가지지만, 커밋·브랜치 등의 메타데이터(`.git` 폴더)는 서로 공유합니다. 그래서 여러 브랜치를 병렬로 체크아웃하고 작업할 수 있습니다.

## 용어

  * **로컬 체크아웃** : 사용자가 만든 저장소입니다. Codex 앱에서는 간단히 **Local**이라고도 부릅니다.
  * **워크트리** : Codex 앱에서 로컬 체크아웃으로부터 생성된 [Git worktree](https://git-scm.com/docs/git-worktree)입니다.



## 워크트리를 사용하는 이유

  1. 작업 중 서로를 방해하지 않고 Codex와 병렬로 작업할 수 있습니다.
  2. 현재 작업과 무관한 스레드를 시작할 수 있습니다.
     * Codex가 시작해 두길 원하지만 아직 테스트할 준비는 되지 않은 작업을 대기열에 넣어두는 스테이징 영역으로 활용할 수 있습니다.



## 시작하기

워크트리를 사용하려면 Git 저장소가 필요합니다. 선택한 프로젝트가 Git 저장소 안에 있는지 확인하세요.

  1. “Worktree” 선택

새 스레드 화면에서 composer 아래의 **Worktree**를 선택하세요. 필요하면 워크트리용 설정 스크립트를 실행할 [local environment](https://developers.openai.com/codex/app/local-environments)도 선택할 수 있습니다.

  2. 시작 브랜치 선택

composer 아래에서 워크트리의 기준이 될 Git 브랜치를 선택하세요. `main` / `master` 브랜치, 기능 브랜치, 또는 아직 스테이징되지 않은 로컬 변경이 있는 현재 브랜치를 선택할 수 있습니다.

  3. 프롬프트 제출

작업을 제출하면 Codex가 선택한 브랜치를 기준으로 Git 워크트리를 생성합니다. 기본적으로 Codex는 [“detached HEAD”](https://git-scm.com/docs/git-checkout#_detached_head) 상태에서 작업합니다.

  4. 변경 사항 검증

준비가 되면 프로젝트와 작업 흐름에 맞게 [아래](https://developers.openai.com/codex/app/worktrees#verifying-and-pushing-workflow-changes) 경로 중 하나를 따르세요.




## 워크플로 변경 사항 검증 및 푸시

워크트리는 로컬 체크아웃과 거의 동일하게 보이고 동작합니다. 하지만 **Git은 한 번에 한 위치에서만 하나의 브랜치를 체크아웃하도록 허용합니다**. 워크트리에서 브랜치를 체크아웃하면 로컬 체크아웃에서는 동시에 해당 브랜치를 체크아웃할 수 **없고**, 그 반대도 마찬가지입니다.

따라서 워크트리에서 Codex가 만든 변경 사항을 검증하고 커밋하는 방식을 선택해야 합니다.

  1. [워크트리에서만 작업](https://developers.openai.com/codex/app/worktrees#option-1-working-on-the-worktree)합니다. [local environment 설정 스크립트](https://developers.openai.com/codex/app/local-environments)를 사용해 의존성과 도구가 설치되어 있어 워크트리에서 바로 검증할 수 있는 경우에 가장 적합합니다.
  2. [로컬 체크아웃에서 작업](https://developers.openai.com/codex/app/worktrees#option-2-working-in-your-local-checkout)합니다. 앱을 한 인스턴스만 실행할 수 있는 경우처럼, 변경 사항을 메인 체크아웃으로 가져와야 할 때 사용하세요.



### 옵션 1: 워크트리에서 작업

변경 사항과 함께 워크트리에서만 계속 작업하려면 스레드 헤더의 **Create branch here** 버튼으로 워크트리를 브랜치로 전환하세요.

이후에는 변경 사항을 커밋하고, 브랜치를 원격 저장소로 푸시하고, GitHub에서 pull request를 열 수 있습니다.

헤더의 “Open” 버튼으로 IDE를 워크트리에서 열거나, 통합 터미널을 사용하는 등 워크트리 디렉터리에서 필요한 작업을 수행할 수 있습니다.

워크트리에서 브랜치를 생성하면 로컬 체크아웃을 포함한 다른 어떤 워크트리에서도 해당 브랜치를 체크아웃할 수 없다는 점을 기억하세요.

이 브랜치에서 계속 작업할 계획이라면 [사이드바에 추가](https://developers.openai.com/codex/app/worktrees#adding-a-worktree-to-the-sidebar)할 수 있습니다. 그렇지 않다면 작업이 끝난 뒤 스레드를 보관 처리하여 워크트리를 삭제할 수 있게 하세요.

### 옵션 2: 로컬 체크아웃에서 작업

워크트리에서 직접 변경 사항을 검증하지 않고 로컬 체크아웃에서 확인하려면, 스레드 헤더의 **Sync with local**을 클릭하세요.

새 브랜치를 만들지, 기존 브랜치로 동기화할지 선택할 수 있습니다.

언제든 로컬과 동기화할 수 있습니다. 다시 헤더의 **Sync with local**을 클릭하면 됩니다. 여기서 동기화 방향(로컬로 또는 로컬에서)과 동기화 방식을 선택할 수 있습니다.

  * **Overwrite** : 대상 체크아웃의 파일과 커밋 이력이 소스 체크아웃과 일치하도록 만듭니다.
  * **Apply** : 가장 가까운 공통 커밋 이후의 소스 변경 사항을 계산해 대상 체크아웃에 패치로 적용합니다. 이렇게 하면 대상의 커밋 이력은 유지하면서 소스 코드 변경 사항(소스 커밋 자체는 아님)을 가져올 수 있습니다.



여러 워크트리를 만들어 동일한 기능 브랜치에 동기화하면 작업을 병렬 스레드로 나눌 수 있습니다.

경우에 따라 워크트리의 변경 사항이 로컬 체크아웃의 변경 사항(예: 이전 워크트리 테스트 결과)과 충돌할 수 있습니다. 이런 경우 **Overwrite local** 옵션으로 기존 변경 사항을 재설정한 뒤 워크트리 변경 사항을 깔끔하게 적용할 수 있습니다.

이 과정은 Git 연산을 사용하므로 `.gitignore` 파일에 포함된 파일은 동기화 중 전송되지 않습니다.

## 사이드바에 워크트리 추가

위의 옵션 1(워크트리에서 작업)을 선택한 경우, 워크트리에 브랜치를 만든 뒤 스레드 헤더에 워크트리를 사이드바에 추가하는 옵션이 나타납니다. 이렇게 하면 해당 워크트리가 영구 작업 공간으로 승격됩니다. 이 작업을 하면 자동 삭제되지 않으며, 같은 워크트리에서 새 스레드를 시작할 수도 있습니다.

## 고급 세부 정보

### Codex가 워크트리를 관리하는 방식

Codex는 `$CODEX_HOME/worktrees` 아래에 워크트리를 생성합니다. 시작 커밋은 스레드를 시작할 때 선택한 브랜치의 `HEAD` 커밋입니다. 로컬 변경 사항이 있는 브랜치를 선택했다면 커밋되지 않은 변경 사항도 워크트리에 함께 적용됩니다. 워크트리는 브랜치로 체크아웃되지 않으며, [detached HEAD](https://git-scm.com/docs/git-checkout#_detached_head) 상태가 됩니다. 즉, 브랜치를 어지럽히지 않고 여러 워크트리를 만들 수 있습니다.

### 브랜치 제한 사항

Codex가 워크트리에서 작업을 마친 뒤 **Create branch here**로 `feature/a` 브랜치를 만들었다고 가정해 보겠습니다. 이제 이를 로컬 체크아웃에서 확인하고 싶습니다. 이 브랜치를 체크아웃하려고 하면 다음 오류가 발생합니다.
[code] 
    fatal: 'feature/a' is already used by worktree at '<WORKTREE_PATH>'
[/code]

이 문제를 해결하려면 워크트리에서 `feature/a` 대신 다른 브랜치를 체크아웃해야 합니다.

브랜치를 로컬에서 체크아웃할 계획이라면 워크플로 2([sync with local](https://developers.openai.com/codex/app/worktrees#option-2-working-in-your-local-checkout))를 사용해 보세요.

이 제한이 존재하는 이유

Git은 같은 브랜치를 동시에 둘 이상의 워크트리에서 체크아웃하지 못하게 합니다. 브랜치는 단일 가변 참조(`refs/heads/<name>`)를 나타내며, 그 의미는 워킹 트리의 “현재 체크아웃된 상태”이기 때문입니다.

브랜치가 체크아웃되면 Git은 해당 브랜치의 HEAD를 그 워크트리가 소유한다고 간주하고, 커밋·리셋·리베이스·병합 같은 연산이 잘 정의되고 직렬화된 방식으로 그 참조를 전진시킬 것을 기대합니다. 여러 워크트리에서 같은 브랜치를 동시에 체크아웃하도록 허용하면 어떤 워크트리의 연산이 브랜치 참조를 갱신하는지에 대한 모호성과 경쟁 상태가 생겨, 커밋 유실·인덱스 불일치·충돌 해결의 불명확성으로 이어질 수 있습니다.

Git은 워크트리당 하나의 브랜치 규칙을 강제함으로써 각 브랜치에 대해 단일 권위 작업 복사본을 보장하면서도, 다른 워크트리가 detached HEAD 또는 별도 브랜치를 통해 동일한 커밋을 안전하게 참조할 수 있게 합니다.

### 워크트리 정리

워크트리는 디스크 공간을 많이 차지할 수 있습니다. 각 워크트리에는 저장소 파일, 의존성, 빌드 캐시 등이 각각 존재합니다. 그래서 Codex 앱은 워크트리 수를 합리적인 범위로 유지하려고 합니다.

다음 조건에서는 워크트리가 절대 정리되지 않습니다.

  * 고정된 대화가 해당 워크트리에 연결된 경우
  * 워크트리가 사이드바에 추가된 경우(위 참고)



다음 조건에서는 워크트리가 정리 대상이 됩니다.

  * 생성 후 4일이 지난 경우
  * 워크트리가 10개를 초과하는 경우



위 조건 중 하나라도 충족되면, Codex는 스레드를 보관 처리할 때 워크트리를 자동으로 정리합니다. 또는 연결된 스레드가 없는 워크트리를 앱 시작 시 발견하면 그때 정리합니다.

워크트리를 정리하기 전에 Codex는 해당 작업의 스냅샷을 저장하며, 이후 언제든 새 워크트리에서 복원할 수 있습니다. 워크트리가 정리된 뒤 대화를 열면 복원 옵션이 표시됩니다.

## 자주 묻는 질문

워크트리가 생성되는 위치를 제가 제어할 수 있나요?

현재는 불가능합니다. Codex는 일관된 관리를 위해 `$CODEX_HOME/worktrees` 아래에 워크트리를 생성합니다.

워크트리 간에 세션을 이동할 수 있나요?

아직은 불가능합니다. 환경을 바꿔야 한다면 대상 환경에서 새 스레드를 시작하고 프롬프트를 다시 입력해야 합니다. composer에서 위쪽 화살표 키를 사용해 프롬프트를 복구해 볼 수 있습니다.

워크트리가 삭제되면 스레드는 어떻게 되나요?

기반 워크트리 디렉터리가 정리되더라도 스레드는 기록에 남아 있을 수 있습니다. 다만 Codex는 정리 전에 워크트리 스냅샷을 저장하며, 해당 스레드를 다시 열면 복원 옵션을 제공합니다.
